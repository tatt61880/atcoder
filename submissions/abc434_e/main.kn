func main()
	var n: int :: cui@inputInt()
	var x: []int :: #[n]int
	var r: []int :: #[n]int
	
	for i(0, n - 1)
		do x[i] :: cui@inputInt()
		do r[i] :: cui@inputInt()
	end for
	
	var dic: dict<int, int> :: #dict<int, int>
	var id: int :: 0
	for i(0, n - 1)
		for d(-1, 1)
			if(d = 0)
				skip d
			end if
			var e: int :: x[i] + d * r[i]
			var exist: bool
			do dic.get(e, &exist)
			if(!exist)
				do dic.add(e, id)
				do id :+ 1
			end if
		end for
	end for
	
	var uni: UnionFind :: (#UnionFind).init(id)
	
	for i(0, n - 1)
		var u: int :: x[i] - r[i]
		var v: int :: x[i] + r[i]
		do uni.unite(dic.get(u, &), dic.get(v, &))
	end for
	
	var eNums: []int :: #[id]int
	var vNums: []int :: #[id]int
	
	for i(0, n - 1)
		var u: int :: x[i] - r[i]
		do eNums[uni.root(dic.get(u, &))] :+ 1
	end for
	
	for i(0, id - 1)
		do vNums[uni.root(i)] :+ 1
	end for
	
	var ans: int :: 0
	for i(0, id - 1)
		if(vNums[i] > 0)
			do ans :+ vNums[i] = eNums[i] + 1 ?(eNums[i], vNums[i])
		end if
	end for
	do cui@print("\{ans}\n")
	
	class UnionFind()
		var parents: []int
		+func init(n: int): UnionFind
			do me.parents :: [-1].repeat(n)
			ret me
		end func
		+func size(x: int): int
			ret -me.parents[me.root(x)]
		end func
		+func same(x: int, y: int): bool
			ret me.root(x) = me.root(y)
		end func
		+func unite(x: int, y: int): bool
			do x :: me.root(x)
			do y :: me.root(y)
			if(x = y)
				ret false
			end if
			if(me.parents[x] > me.parents[y])
				do me.parents[y] :+ me.parents[x]
				do me.parents[x] :: y
			else
				do me.parents[x] :+ me.parents[y]
				do me.parents[y] :: x
			end if
			ret true
		end func
		+func root(x: int): int
			if(me.parents[x] < 0)
				ret x
			else
				do me.parents[x] :: me.root(me.parents[x])
				ret me.parents[x]
			end if
		end func
	end class
end func
