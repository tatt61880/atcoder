func main()
	var n: int :: cui@inputInt()
	var q: int :: cui@inputInt()
	var uni: UnionFind :: (#UnionFind).init(n)
	
	for(1, q)
		var t: int :: cui@inputInt()
		var u: int :: cui@inputInt()
		var v: int :: cui@inputInt()
		if(t = 0)
			do uni.unite(u, v)
		else
			var ans: bool :: uni.same(u, v)
			do cui@print((ans ?("1", "0")) ~ "\n")
		end if
	end for
	
	
	class UnionFind()
		var parents: []int
		+func init(n: int): UnionFind
			do me.parents :: [-1].repeat(n)
			ret me
		end func
		+func size(x: int): int
			ret -me.parents[me.root(x)]
		end func
		+func same(x: int, y: int): bool
			ret me.root(x) = me.root(y)
		end func
		+func unite(x: int, y: int): bool
			do x :: me.root(x)
			do y :: me.root(y)
			if(x = y)
				ret false
			end if
			if(me.size(x) < me.size(y))
				do me.parents[y] :+ me.parents[x]
				do me.parents[x] :: y
			else
				do me.parents[x] :+ me.parents[y]
				do me.parents[y] :: x
			end if
			ret true
		end func
		
		func root(x: int): int
			if(me.parents[x] < 0)
				ret x
			else
				do me.parents[x] :: me.root(me.parents[x])
				ret me.parents[x]
			end if
		end func
	end class
end func
