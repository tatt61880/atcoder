func main()
	var n: int :: cui@inputInt()
	var q: int :: cui@inputInt()
	
	var seg: @SegmentTree :: (#@SegmentTree).init(n)
	for i(0, n - 1)
		var a: int :: cui@inputInt()
		do seg.update(i, a)
	end for
	
	for(1, q)
		var t: int :: cui@inputInt()
		if(t = 1)
			var x: int :: cui@inputInt()
			var v: int :: cui@inputInt()
			do seg.update(x - 1, v)
		elif(t = 2)
			var l: int :: cui@inputInt()
			var r: int :: cui@inputInt()
			var v: int :: seg.query(l - 1, r)
			do cui@print("\{v}\n")
		else
			var x: int :: cui@inputInt()
			var v: int :: cui@inputInt()
			var ok: int :: n + 1
			var ng: int :: x - 1
			while((ok - ng).abs() > 1)
				var mid: int :: (ok + ng) / 2
				if(isOk(mid, seg, x, v))
					do ok :: mid
				else
					do ng :: mid
				end if
			end while
			var ans: int :: ok
			do cui@print("\{ans}\n")
			
			func isOk(mid: int, seg: @SegmentTree, x: int, v: int): bool
				ret seg.query(x - 1, mid) >= v
			end func
		end if
	end for
end func

class SegmentTree()
	const zero: int :: 0
	var size: int
	var node: []int
	
	+func init(n: int): SegmentTree
		do me.size :: 1
		while(me.size < n)
			do me.size :* 2
		end while
		do me.node :: #[2 * me.size]int
		for i(0, 2 * me.size - 1)
			do me.node[i] :: zero
		end for
		ret me
	end func
	
	+func update(idx: int, val: int)
		do idx :+ me.size - 1
		do me.node[idx] :: val
		while(idx > 0)
			do idx :: (idx - 1) / 2
			do me.node[idx] :: lib@max(me.node[2 * idx + 1], me.node[2 * idx + 2])
		end while
	end func
	
	+func query(a: int, b: int): int
		ret me.querySub(a, b, 0, 0, me.size)
	end func
	
	func querySub(a: int, b: int, k: int, l: int, r: int): int
		if(b <= l | r <= a)
			ret zero
		end if
		if(a <= l & r <= b)
			ret me.node[k]
		end if
		var vl: int :: me.querySub(a, b, 2 * k + 1, l, (l + r) / 2)
		var vr: int :: me.querySub(a, b, 2 * k + 2, (l + r) / 2, r)
		ret lib@max(vl, vr)
	end func
	
	+*func toStr(): []char
		var padding: int :: 1
		while(padding <= me.size)
			do padding :* 2
		end while
		do padding :- 1
		var res: []char :: ""
		var s: int :: 0
		var e: int :: 0
		var n: int :: 1
		const digit: int :: 6
		var fmt: []char :: " \{digit}d"
		var strInf: []char :: " ".repeat(digit - 3) ~ "inf"
		while(padding > 0)
			do padding :/ 2
			for i(s, e)
				do res :~ " ".repeat((digit + 1) * padding)
				do res :~ "\{me.node[i] = zero ?(strInf, me.node[i].toStrFmt(fmt))}|"
			end for
			do res :~ "\n"
			do n :* 2
			do s :: e + 1
			do e :: s + n - 1
		end while
		ret res
	end func
end class